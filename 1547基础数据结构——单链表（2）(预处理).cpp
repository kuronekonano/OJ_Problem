#include <stdio.h>
#include <string.h>
bool vis[61311]; /// 标记数组，检查当前数字是否被删除
int note[3008];  /// 记录第n个幸运数字
void inti()      /// 大型暴力预处理（竟然没爆时间）
{
  int i, j, num = 1;
  for (
      i = 2; i <= 61234;
      i++) /// 这个六万多是预估的，根据大神说，越到后面删除的数应该越少，因此被遍历的数应该不是很大(写到后面才知道因为后面的幸运数字很大，那么他的倍数(删除数)也被拉到很后面去了)
  {        /// 外层循环，寻找从2号到n号每个的倍数
    if (vis[i] == false) /// 先看正在遍历的这个数是不是被删除的
    {
      note[num++] =
          i; /// 没被删除就记录到幸运数字的数组里，因为从一开始的2就一直往后删除倍数，那么能被遍历到的未被删除的数一定是幸运数
      if (num > 3000) /// 只需要3000个幸运数
        break;        /// 超过就可以结束预处理了
      int t = 0;      /// 这里表示多少多少的倍数计数(竟然是土方法)
      for (j = i + 1; j <= 61234;
           j++) /// 内层循环是找到当前遍历的幸运数字的所有倍数，并删除
      {
        if (vis[j] == false)
          t++; /// 如果从幸运数字往后+1的这个数字(j)没有被删除，那么它就是可以计数的，此时计数器t将其算入
        if (t == i) /// 当计数器达到相应倍数时(等于i)就将这个数删除
        {
          vis[j] = true; ///(删除)
          t = 0;         ///(计数器归零继续找下一个倍数)
        }
      } /// 就这样模拟每个找倍数的过程，然后检查是否被删除，一个个收录幸运数到数组中，最后直接输出即可
    }
  }
}
int main() {
  memset(vis, false, sizeof(vis)); /// 清空表计算数组
  inti();                          /// 预处理
  int n;
  while (scanf("%d", &n) != EOF) {
    printf("%d\n", note[n]);
  }
  return 0;
}
