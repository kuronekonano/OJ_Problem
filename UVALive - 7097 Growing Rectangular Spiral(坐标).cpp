#include<stdio.h>
int main()
{
    int t,x,y,k;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d%d%d",&k,&x,&y);
        if(x>=y)
            if(x-y+5<x+2&&x-y+5>3) printf("%d 6 1 2 3 %d %d %d\n",k,x-y+5,x+2,x+3);
            else printf("%d NO PATH\n",k);
        else printf("%d 2 %d %d\n",k,x,y);
    }
}
///每条回旋边都要比上一条边长，因此当x<y时满足先横向小于后纵向的条件，直接两条边输出坐标即可
///当x>=y时，需要进行回旋，可以发现如果能到达任何一个点一定是6条边就能到达。
///前3条边，按总长度最小，应该是1 2 3,从第四条边开始影响到达的点的位置
///因为前三条边已经定下来，定下来的边将x小于等于1的区域，y小于等于2的区域包围住。这些区域是到达不了的
///因此，横向边(第五条)的长度应该补齐到达第二象限的两格负数
///第五条长度=目标横坐标+2
///第六条长度=目标横坐标+3  为保证总长度最短，第六条边不控制纵向长度，因此只需要比上一条横向边长1个单位即可
///控制纵向到达目标点的是第四条边，第四条边纵深多少，将影响第六条边是否能到达目标y坐标
///第四条长度=第六条-目标纵坐标+2
///第六条边由  目标纵坐标+第四条边纵深长度组成
///纵深长度，第四条边和第六条边是一样的，因此可以由第六条边减去目标y求出。
///这就是第四条边的一部分，然后再加上y轴正半轴中固定的2个正单位长度，就是第四条边长度
///又因为 第六条边长度=x+3，等价代换  x+3-y+2=x-y+5为第四条边长度
