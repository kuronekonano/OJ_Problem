#include<stdio.h>///将问题简化为，判断是否是一整个大环，也就是判断是否存在多个环，存在几个环
#include<string.h>///如果存在几个环，就要改动几次，将其变成一个大环
bool vis[200008];///题目原意为，有n个烤架，分别为p1,p2,p3....pn，每个烤炉上有个标识b1,b2,b3...bn表示到达这个烤炉时要不要翻面
int p[200008];///问，要将n个烤肉，使每个烤肉都在所有烤架上烤过，并且是两面都烤过，需要将现有的顺序最少改动几次
void dfs(int i)///p1,p2,p3等数组上表示的数字，指的是在这个烤炉上的肉，下一秒将要到达几号烤炉，也就是链状表示。
{
    vis[i]=true;
    if(!vis[p[i]])
    {
        dfs(p[i]);
    }
}
int main()///如果这样的链状表示，使一个烤肉可以通过此种传递循环一圈，则形成一个环，如果这个环到达过每个烤炉，这就是题目要求的情况，所有烤炉形成大环。
{
    int i,n,flag,ans,tmp;
    while(scanf("%d",&n)!=EOF)///还有就是，关于每个烤炉都要烤肉的双面，可以直接模拟一下，发现有奇数个1(到达此烤炉需要翻面)时，每圈到达每个烤炉的正反状态都会不同
    {
        flag=0;
        memset(vis,false,sizeof(vis));///这就实现了多转两圈后，所有肉在每个烤炉上烤过双面。
        for(i=1;i<=n;i++)scanf("%d",&p[i]);
        for(i=1;i<=n;i++)
        {
            scanf("%d",&tmp);
            if(tmp)flag++;///直接计数1的个数，如果为偶数，说明要改变某个为烤炉的01状态，操作数+1
        }
        ans=0;
        if(flag%2==0)ans++;
        flag=0;
        for(i=1;i<=n;i++)///判断环的数量时，用标记数组vis和深入传递的深搜，从第一个入手，一次搜到底，再遍历剩下的烤炉，如果还有未标记的说明不止一个环，因为上次遍历环还有烤炉没有到达过
        {
            if(!vis[i])
            {
                flag++;
                dfs(i);
            }
        }
        if(flag==1)flag=0;///如果环的计数只有1，说明就是一个大环，不需要操作，操作数为0
        printf("%d\n",ans+flag);///最后结果是环的数量(同时也是将其改变成一整个大环的操作数)加上01状态的操作数
    }
}
