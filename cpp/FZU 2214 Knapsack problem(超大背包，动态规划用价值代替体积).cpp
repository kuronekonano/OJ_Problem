#include <algorithm>  ///按常规背包，横行表示达到第i容积时，能装下的最大价值，此时因为容积太大，体积也太大，无法用数组来表示了
#include <stdio.h>    ///题目有着超大的背包容积，以及超大的物体体积
using namespace std;  /// 因为这题的价值总和较少，所有500个物体的价值总和小于等于5000，因此可以交换一下，利用价值做横行来dp
struct bag            /// dp数组中，原本记录的是，当i的容积时，能装下最多dp[i]的价值
{
    int w, v;  /// 交换之后，变为，横行表示价值，记录当达到i价值时的最小dp[i]总体积
} a[ 508 ];
long long dp[ 5050 ];  /// 注意dp数组中是很大的数，存储了很大的容积
int       main() {
    int t;
    scanf( "%d", &t );
    while ( t-- ) {
        int       n, b, i, j, vsum = 0;  /// 价值总和不大
        long long wsum = 0;              /// 容积总和很大
        scanf( "%d%d", &n, &b );
        for ( i = 1; i <= n; i++ ) {
            scanf( "%d%d", &a[ i ].w, &a[ i ].v );
            vsum = vsum + a[ i ].v;  /// 记录最大总价值，用于标记从哪里开始倒序遍历
            wsum = wsum + a[ i ].w;  /// 记录最大总体积，用于初始化dp数组中元素，因为是找能达到v的最小体积，因此初始化都最大的值
        }
        for ( i = 1; i <= vsum; i++ ) {
            dp[ i ] = wsum;
        }
        dp[ 0 ] = 0;                /// 当0价值时，体积也必定是0，递推边界
        for ( i = 1; i <= n; i++ )  /// 从第1个物品开始
        {
            for ( j = vsum; j >= a[ i ].v; j-- )  /// 最大价值开始向前遍历，直到遍历第i个物品的价值，说明达到这个物品价值的体积，就是这个物品的体积
            {
                dp[ j ] = min( dp[ j ], dp[ j - a[ i ].v ] + a[ i ].w );
            }
        }
        int ans = 0;
        for ( i = vsum; i >= 0; i-- )  /// dp完成后，将从最大价值回头遍历，查找当dp[i]==背包容积时，所能达到的最大体积(也就是v体积时使用的最小体积)
        {
            if ( dp[ i ] <= b ) {
                ans = i;
                break;
            }
        }
        printf( "%d\n", ans );
    }
    return 0;
}
/*解题思路：咋一看是简单地背包问题，不过数据过大，无法开数组。不过注意到价值的数据较小。可以将物品的价值和体积位置调换，
dp[j]的含义改变为装价值为j的的物品，至少需要多大的容量。运用背包求解（注意：此处的01背包要求恰好装满），求出最后各个价值
所需的最小容量，然后通过与限制B进行比较，求出最大容量。*/

/*初始化问题：有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背
包装满。如果是第一种问法，要求恰好装满背包 ，那么在初始化时除了F[0]为0，其
它F[1..V ]均设为−∞，这样就可以保证最终得到的F[V ]是一种恰好装满背包的 最优解。
如果并没有 要求必须把背包装满，而是只希望价格尽量大，初始化时应该 将F[0..V
]全部设为0。 */
