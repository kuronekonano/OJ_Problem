#include <stdio.h>
#include <string.h>
bool vis[ 61311 ];  /// 标记数组，检查当前数字是否被删除
int  note[ 3008 ];  /// 记录第n个幸运数字
void inti()         /// 大型暴力预处理（竟然没爆时间）
{
    int i, j, num = 1;
    for ( i = 2; i <= 61234;
          i++ )                   /// 这个六万多是预估的，根据大神说，越到后面删除的数应该越少，因此被遍历的数应该不是很大(写到后面才知道因为后面的幸运数字很大，那么他的倍数(删除数)也被拉到很后面去了)
    {                             /// 外层循环，寻找从2号到n号每个的倍数
        if ( vis[ i ] == false )  /// 先看正在遍历的这个数是不是被删除的
        {
            note[ num++ ] = i;                  /// 没被删除就记录到幸运数字的数组里，因为从一开始的2就一直往后删除倍数，那么能被遍历到的未被删除的数一定是幸运数
            if ( num > 3000 )                   /// 只需要3000个幸运数
                break;                          /// 超过就可以结束预处理了
            int t = 0;                          /// 这里表示多少多少的倍数计数(竟然是土方法)
            for ( j = i + 1; j <= 61234; j++ )  /// 内层循环是找到当前遍历的幸运数字的所有倍数，并删除
            {
                if ( vis[ j ] == false )
                    t++;       /// 如果从幸运数字往后+1的这个数字(j)没有被删除，那么它就是可以计数的，此时计数器t将其算入
                if ( t == i )  /// 当计数器达到相应倍数时(等于i)就将这个数删除
                {
                    vis[ j ] = true;  ///(删除)
                    t        = 0;     ///(计数器归零继续找下一个倍数)
                }
            }  /// 就这样模拟每个找倍数的过程，然后检查是否被删除，一个个收录幸运数到数组中，最后直接输出即可
        }
    }
}
int main() {
    memset( vis, false, sizeof( vis ) );  /// 清空表计算数组
    inti();                               /// 预处理
    int n;
    while ( scanf( "%d", &n ) != EOF ) {
        printf( "%d\n", note[ n ] );
    }
    return 0;
}
