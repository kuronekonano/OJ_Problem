// #include<stdio.h>
// int main()
//{
//     int i,n;
//     while(scanf("%d",&n)!=EOF)
//     {
//         int flag=1;
//         for(i=1;i<n;i++)
//         {
//             flag=flag*2+1;
//         }
//         printf("%d\n",flag);
//     }
//     return 0;
// }
/// 假设有n片，移动次数是f(n).显然f(1)=1,f(2)=3,f(3)=7，且f(k+1)=2*f(k)+1。
// #include<stdio.h>///递推数组
// int main()
//{
//     int a[50];
//     int i,n;
//     while(scanf("%d",&n)!=EOF)
//     {
//         a[1]=1;
//         for(i=2;i<=n;i++)
//         {
//             a[i]=a[i-1]*2+1;
//         }
//         printf("%d\n",a[n]);
//     }
//     return 0;
// }
/// 一个盘从第一个移动到第三个需要异步
/// 两个盘从第一个移动到第三个分成，两个1个盘移动到第三个，其中一个从第一个到第三个需要一步，另一个从第一个到第二个，再从第二个到第三个，共需要2*一个盘的步数,也就是说从一个移动到另一个需要3次
/// 三个盘从第一个移动到第三个分成，一个1个盘移动到第三个和一个(两个盘看作一个整体)2个盘移动到第三个，其中单个盘从第一个移动到第三个需要1步，另外两个盘需要从第一个移动到第二个，需要3次，再从第二个移动到第三个需要3次，因此是
/// 两倍的2盘挪动次数+一次单个盘挪动次数，每次增加一个盘，都是之前盘数(n-1)的次数的2倍+单独移动一次1个盘的次数
/// 也就是.......2*(2*(2*(2*n+1)+1)+1
#include <bits/stdc++.h>
using namespace std;

void hanoi(int n, char a, char b, char c) {
  if (n >= 1) {
    hanoi(n - 1, a, c, b); /// 每次最小的要较大的上面，而不是较大的挪到小的上面
    printf("%c --> %c \n", a, c);
    hanoi(n - 1, b, a, c);
  }
}

int main() {
  int n;
  printf("Input the number of diskes:\n");
  scanf("%d", &n);
  hanoi(n, 'A', 'B', 'C');
}
///    实现这个算法可以简单分为三个步骤：
///
/// 　　　　（1）     把n-1个盘子由A 移到 B；
///
/// 　　　　（2）     把第n个盘子由 A移到 C；
///
/// 　　　　（3）     把n-1个盘子由B 移到 C；
///
/// 从这里入手，在加上上面数学问题解法的分析，我们不难发现，移到的步数必定为奇数步：
///
/// 　　　　（1）中间的一步是把最大的一个盘子由A移到C上去；
///
/// 　　　（2）中间一步之上可以看成把A上n-1个盘子通过借助辅助塔（C塔）移到了B上，
///
/// 　　　（3）中间一步之下可以看成把B上n-1个盘子通过借助辅助塔（A塔）移到了C上；
