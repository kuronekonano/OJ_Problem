#include <stdio.h>
#include <string.h>
long long sum( long long x )  /// 组合数C(3,x),从x个点中任意取三个作为三角形三点
{
    return x * ( x - 1 ) * ( x - 2 ) / 6;
}
long long gcd( int x, int y )  /// GCD写错了一直查不到错
{
    while ( y != 0 ) {
        long long c = y;
        y           = x % y;
        x           = c;
    }
    return x;
}
int main()  /// 容斥原理，先算所有格子中任意取3点的数量，减去三点共线的数量
{
    long long n, m;  /// 输入n*m个格子，其中有n+1行，m+1列
    while ( scanf( "%lld%lld", &n, &m )
            != EOF ) {  /// 首先计算所有点取3点的数量，组合数求，接着减去同在一行和一列的所有情况，那么就是n+1长度的一列上有C(3,K)的种类，总共有m+1列这样的长度，同样m+1长度的n+1行也是一样
        long long ans = sum( ( n + 1 ) * ( m + 1 ) ) - ( m + 1 ) * sum( n + 1 ) - ( n + 1 ) * sum( m + 1 );
        for ( int i = 1; i <= n; i++ )      /// 除去横向和纵向，接下来是斜着的重复数量，首先从源点0,0开始以不同斜率连接除边界外的每一个点，求GCD(i,j)-1得到在0,0和i,j之间有多少可选点构成三点一线
        {                                   /// 此处以0,0作为源点，i,j作为一个小的矩形范围内出现重复的区域，以i,j为另一定点，取两定点中间多个动点作为第三个点，有gcd(i,j)-1的匹配数量三点一线
            for ( int j = 1; j <= m; j++ )  /// 逐个减去不会重复或少减
            {
                ans -= 2 * ( gcd( i, j ) - 1 ) * ( m + 1 - j )
                       * ( n + 1
                           - i );  /// 算出以左上角矩形为基点的所有斜向共线可能后，以当前i,j小矩形为一范围，向下平移(n+1-i)个单位得到不同种数，向右平移(m+1-j)个单位得到同样大小的矩形在其他基点的种数
            }  /// 相乘后得到该大小矩形在所有区域的不重复共线可能，然后*2，表示左斜和右斜两种情况
        }
        printf( "%lld\n", ans );  /// 减去所有共线可能后得到最终结果
    }
}
