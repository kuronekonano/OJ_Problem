#include <stdio.h>
#include <string.h> ///两列矩阵，按扫雷的规则，第一列可能有地雷，没地雷的位置有数字，第二列一定没雷，全是数字
int a[10004], b[10004], n,
    ans; /// 给出第二列的数字，用于判断第一列可能有的地雷排列方案数
void judge(int st) {
  for (int i = st; i < n; i++)
    a[i + 1] =
        b[i] - a[i] -
        a[i -
          1]; /// 接下来从第1列第三个位置(i+1)之后的雷数分配，b[i]表示当前三个位置a[i]+a[i+1]+a[i-1]的总和，在推出前两个数量的情况下可以得到第三个的数量
  ans =
      a[n]
          ? ans
          : ans +
                1; /// 如果最后的格子之后仍有雷剩余，表示分配和实际不符，若刚好分配完雷，则方案数+1
}
int main() {
  while (scanf("%d", &n) != EOF) {
    ans = 0;
    for (int i = 0; i < n; i++)
      scanf("%d", &b[i]);
    for (int i = 0; i <= b[0];
         i++) /// 从第二列的第一个位置开始地推第一列是否有地雷
    {         /// 第二列第一个数字表示了第一列的第一和第二个位置是否有地雷
      memset(a, 0, sizeof(a)); /// 初始化埋雷列
      a[0] = i,
      a[1] =
          b[0] -
          i; /// 为0的时候是第一个位置有雷，其他数字表示当前位置无雷，b[0]-i表示第二列第一个说明第一列第一和第二雷总数，i表示第一列第一个雷数，得到第一列第二个雷数
      judge(1);
    }
    printf("%d\n", ans);
  }
}
