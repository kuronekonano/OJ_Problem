#include <stdio.h>
int main() {
    int t, x, y, k;
    scanf( "%d", &t );
    while ( t-- ) {
        scanf( "%d%d%d", &k, &x, &y );
        if ( x >= y )
            if ( x - y + 5 < x + 2 && x - y + 5 > 3 )
                printf( "%d 6 1 2 3 %d %d %d\n", k, x - y + 5, x + 2, x + 3 );
            else
                printf( "%d NO PATH\n", k );
        else
            printf( "%d 2 %d %d\n", k, x, y );
    }
}
/// 每条回旋边都要比上一条边长，因此当x<y时满足先横向小于后纵向的条件，直接两条边输出坐标即可
/// 当x>=y时，需要进行回旋，可以发现如果能到达任何一个点一定是6条边就能到达。
/// 前3条边，按总长度最小，应该是1 2 3,从第四条边开始影响到达的点的位置
/// 因为前三条边已经定下来，定下来的边将x小于等于1的区域，y小于等于2的区域包围住。这些区域是到达不了的
/// 因此，横向边(第五条)的长度应该补齐到达第二象限的两格负数
/// 第五条长度=目标横坐标+2
/// 第六条长度=目标横坐标+3
/// 为保证总长度最短，第六条边不控制纵向长度，因此只需要比上一条横向边长1个单位即可
/// 控制纵向到达目标点的是第四条边，第四条边纵深多少，将影响第六条边是否能到达目标y坐标
/// 第四条长度=第六条-目标纵坐标+2
/// 第六条边由  目标纵坐标+第四条边纵深长度组成
/// 纵深长度，第四条边和第六条边是一样的，因此可以由第六条边减去目标y求出。
/// 这就是第四条边的一部分，然后再加上y轴正半轴中固定的2个正单位长度，就是第四条边长度
/// 又因为 第六条边长度=x+3，等价代换  x+3-y+2=x-y+5为第四条边长度
