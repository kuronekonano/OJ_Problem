#include <algorithm>
#include <stdio.h> ///有n个人打比赛，问最后赢的人最多要打多少场比赛，参加比赛场次相差不过1的两人才能比赛
using namespace std;
int main() {
  long long n, a[556];
  a[1] =
      2; /// 如果赢了1场比赛，那么至少可能有2个人，如果最后赢了2场比赛，那么至少有3个人比赛，依次类推
  a[2] = 3;
  int i = 2;
  while (
      a[i] <=
      1e18) /// 数组的序号表示最后一共赢的比赛场次，数组中存的数表示赢那么多场次至少有几人参加比赛
  {
    a[++i] =
        a[i - 1] +
        a[i -
          2]; /// 得到类似斐波那契的递推式，如果赢了3场比赛，相当于，在总人数为2人的局中赢了1场，加上在3人局中赢了两场
  } /// 因此赢3场的情况出现在至少5人局中
    /// 依次推算，当赢100场左右时，总人数就会超过1e18，在递推数组中用upper_bound找到n小于某个总人数的位置即是在那个人数下要赢的场次
  //    for(i=1;i<=100;i++)printf("%d  %lld\n",i,a[i]);
  while (scanf("%lld", &n) != EOF) {
    int pos = upper_bound(a, a + i + 1, n) - a;
    printf(
        "%d\n",
        pos -
            1); /// 因为upper_bound找到的是第一个大于n的位置，因此这个位置要-1才是小于等于n的获胜场数
  }
}
