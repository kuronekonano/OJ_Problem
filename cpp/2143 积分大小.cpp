#include <stdio.h>   ///分情况递推，利用dp实现
#include <string.h>  ///要比较n个数中有多少种大小的可能数
int main()  /// 首先先分类，在有n个人时，有1到n个不同大小的数，如n个人中只有1种数，所有数都相等，有1种情况，有2两个不同大小的数时，根据n-1个数中有2个不同大小的数的情况转移而来，在这[n-1][2]个数中
{           /// 分别用新加入的这个数n来替换两个数中的任一一个，在2个不同的位置中更换n值进去，即有[n-1][2]*2种情况，相当于每种情况可以更换2个数各一次，有[n-1][2]种情况要更换
    long long ans[ 20 ], dp[ 22 ][ 22 ], i, j,
        n;  /// 这是在n个数增加时，有同等个数的不同大小值时的状态转移，利用新数n对n-1个数时同样数量的不同值更换得到
    memset( dp, 0,
            sizeof( dp ) );  /// 另一种情况的转移，是通过n-1个数时，有j-1个不同大小的数时的情况数量递推得到，使新加入的这个数n作为和之前所有的数值都不同的存在加入到数列中
    memset( ans, 0,
            sizeof( ans ) );    /// 它可以放在原数列从大到小排列时的任何位置，任意两个不同大小的数之间，也能比所有的数大，比所有的数小，在j-1个不同的值中有j个空隙可以填充
    for ( i = 1; i < 19; i++ )  /// 因此在(i-1,j-1)的情况下，每个空隙都替换一次，产生[i-1][j-1]*j种情况，由此变化而来，
    {
        for ( j = 1; j < 19; j++ )  /// 两种情况，在j个不同的数下，由替换可以得到，由j-1个不同的数增加可以得到，两种情况变化之和即得到i,j下的情况数量
        {
            if ( j == 1 )
                dp[ i ][ j ] = 1;
            else {
                dp[ i ][ j ] = dp[ i - 1 ][ j ] * j + dp[ i - 1 ][ j - 1 ] * j;  /// 最后dp数组中ij存储的是i个数时，j个不同的数的情况数量，把j从1到i所有情况数量求和，即i个数时共有多少种不同的大小排列
            }
            ans[ i ] += dp[ i ][ j ];
        }
    }
    while ( scanf( "%lld", &n ) != EOF ) {
        printf( "%lld\n", ans[ n ] );
    }
}
