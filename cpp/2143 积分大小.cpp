#include <stdio.h>  ///分情况递推，利用dp实现
#include <string.h> ///要比较n个数中有多少种大小的可能数
int main() /// 首先先分类，在有n个人时，有1到n个不同大小的数，如n个人中只有1种数，所有数都相等，有1种情况，有2两个不同大小的数时，根据n-1个数中有2个不同大小的数的情况转移而来，在这[n-1][2]个数中
{ /// 分别用新加入的这个数n来替换两个数中的任一一个，在2个不同的位置中更换n值进去，即有[n-1][2]*2种情况，相当于每种情况可以更换2个数各一次，有[n-1][2]种情况要更换
  long long ans[20], dp[22][22], i, j,
      n; /// 这是在n个数增加时，有同等个数的不同大小值时的状态转移，利用新数n对n-1个数时同样数量的不同值更换得到
  memset(
      dp, 0,
      sizeof(
          dp)); /// 另一种情况的转移，是通过n-1个数时，有j-1个不同大小的数时的情况数量递推得到，使新加入的这个数n作为和之前所有的数值都不同的存在加入到数列中
  memset(
      ans, 0,
      sizeof(
          ans)); /// 它可以放在原数列从大到小排列时的任何位置，任意两个不同大小的数之间，也能比所有的数大，比所有的数小，在j-1个不同的值中有j个空隙可以填充
  for (
      i = 1; i < 19;
      i++) /// 因此在(i-1,j-1)的情况下，每个空隙都替换一次，产生[i-1][j-1]*j种情况，由此变化而来，
  {
    for (
        j = 1; j < 19;
        j++) /// 两种情况，在j个不同的数下，由替换可以得到，由j-1个不同的数增加可以得到，两种情况变化之和即得到i,j下的情况数量
    {
      if (j == 1)
        dp[i][j] = 1;
      else {
        dp[i][j] =
            dp[i - 1][j] * j +
            dp[i - 1][j - 1] *
                j; /// 最后dp数组中ij存储的是i个数时，j个不同的数的情况数量，把j从1到i所有情况数量求和，即i个数时共有多少种不同的大小排列
      }
      ans[i] += dp[i][j];
    }
  }
  while (scanf("%lld", &n) != EOF) {
    printf("%lld\n", ans[n]);
  }
}
