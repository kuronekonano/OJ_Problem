// #include<string.h>///斐波那契连续递推大数运字符串式
// #include<stdio.h>///计算方法是倒序两次被计算的数字字符串，一次用于计算，一次用于存储并输出，存储时是按输出的正序，数组最后一位是个位，个位后有\0结束标识符，0位存储数字的最高位
// int add(char *strc,char *stra,char *strb)///连加函数
//{
//     char result[1005];///计算结果的临时存储数组
//     int lena=strlen(stra);///取a的数组长度，数字a的位数
//     int lenb=strlen(strb);///b的位数
//     int i,lenr;
//     lenr=lena>lenb?lena:lenb;///结果的位数，首先取a与b中最长的那个数的长度，结果肯定大于那个长度
//     lenr++;///根据斐波那契加法计算的规律，两数相加最多进1位，不会超过1位，因此结果数位长度最大设定为加数中最长的数字位数加1
//     result[0]='\0';///因为是倒过来的，所以结果数组第一位是个位（最后输出），第0位就是\0结束标识符
//     for(i=1;i<=lenr;i++)///从第一位个位开始加，加到数组最后一位就是最高位
//     {
//         result[i]='0';///初始化从第一位到最高位为字符0
//     }
//     for(i=1;i<=lena;i++)///先加a再加b
//     {
//         result[i]=result[i]+stra[lena-i]-'0';///这里，第i位是字符，减'0'则为实际的数字，再加上字符stra的第i位，又变回字符，结果就是存的是字符形式
//     }///这里为第一次倒序,比如第1个个位（i），就是存储的正序中的lena-1位，就是减掉个位后的\0，取个位放到计算数组的第1位
//     for(i=1;i<=lenb;i++)
//     {
//         result[i]=result[i]+strb[lenb-i]-'0';
//     }
//     for(i=1;i<=lenr;i++)///进位循环，实际上前面每一位都是算出了字符形式的实际数字，超过字符9的会被取消并进位
//     {
//         if(result[i]>'9')///若大于字符9则进位
//         {
//             result[i]=result[i]-10;///因为都是个位数相加，因此不会超过20，最大为18，所以可以这样用减10来计算实际字符数字存储的数
//             result[i+1]++;///后一位进位
//         }
//     }
//     for(i=lenr;i>1;i--)///最大位数倒着从后面（最高位）开始找,因为斐波那契初始位数就是1，占1位，所以不会低于1，肯定是检查到正数第二位截止
//     {
//         if(result[i]=='0')///如果这一位存储的是0字符，那么说明没有被进位，留出的那个可能进位的最高位无用
//         {
//             lenr--;///最高位减去
//         }
//         else///若找到了最高位，不用继续找，不用继续减最高位总数
//         {
//             break;
//         }
//     }
//     for(i=0;i<=lenr;i++)///倒过来赋值结果数组中的字符串给存储他的数组，这是第二次倒序，取【计算数组】最后一位（最高位），放到【存储输出数组】的第0位
//     {
//         strc[lenr-i]=result[i];///或是【存储输出数组】的最后一位（最高位），接收【计算数组】的第0位（结束标识符\0）
//         【一样的！！！】
//     }
// }
// int main()
//{
//     char
//     c[1005][1005];///只需要一个字符串二维数组，有1000个斐波那契数，每个数有最大1000位
//     int t,n;
//     scanf("%d",&t);///t组数据
//     while(t--)
//     {
//         strcpy(c[1],"1");///因为是字符串，所以复制字符串到第一和第二个斐波那契字符串中
//         strcpy(c[2],"1");
//         scanf("%d",&n);///第n个斐波那契数
//         for(int i=3;i<=n;i++)///循环递推计算
//         {
//             add(c[i],c[i-1],c[i-2]);///投入参数为，要求的第i个斐波那契数，以及数组中上一个及上上一个斐波那契数，每次使用函数都是给c[i]复制的过程
//         }
//         printf("%s\n",c[n]);///输出第n个斐波那契数
//     }
//     return 0;
// }
#include <stdio.h> ///大斐波那契数
#include <string.h>
int a[1005]
     [1008]; /// 一个int数组存储大数即可，有1000个斐波那契数，每个不超过一千位
int main() {
  int i, j, n, t;
  scanf("%d", &t); /// t组数据
  while (t--) {
    scanf("%d", &n);         /// 第n个斐波那契数
    memset(a, 0, sizeof(a)); /// 清空存储数组，相当于每次输入都从头计算
    a[1][1] = a[2][1] = 1;   /// 第一个和第二个斐波那契数都是1
    int num =
        2; /// num表示每个数的位数+1，因此初始的数是1，那么位数加1初始就是2
    int sum = 0;             /// 每个数位的求和数
    int ans = 0;             /// 进位存储
    for (i = 3; i <= n; i++) /// 从第三个斐波那契数开始求，求到第n个
    {
      for (
          j = 1; j < num;
          j++) /// 每个数从数位的个位开始求，存储时，第1位是个位，最高位存储的是最高位，末尾输出时是倒着从最高位输出到第1位的
      {
        sum =
            a[i - 1][j] + a[i - 2][j] +
            ans; /// 大数计算过程，取数组中上一个数和上上一个数的j位依次相加到最高位，每位的和为sum
        a[i][j] =
            sum % 10;   /// 其实第i个斐波那契数的每个j位都是每个数位求和后取摸
        ans = sum / 10; /// 进位的数是求和数除10
      }
      while (ans) /// 若进位在上面的循环中还存在，那么说明总位数num还在增加
      {
        a[i][num++] =
            ans %
            10; /// 大数计算过程，理论上进位时必须模10取个位，但此处因为是斐波那契数列加法计算，因此必定不会超过进一位，可以不用模10
        ans = ans / 10; /// 进位之后除10消去进完的那一位
      }
    } /// 计算完毕
    for (i = num - 1; i >= 1; i--) /// 倒叙输出每一位
    {
      printf("%d", a[n][i]);
    }
    printf("\n");
  }
  return 0;
}
