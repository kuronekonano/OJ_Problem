#include <algorithm>
#include <stdio.h>  ///活用dp
#include <string.h>
using namespace std;  /// 需要注意的是，数据给的是被抓的概率，因此是要相乘(不是相加！！)才能得到同时抢几家银行被抓的概率，但这样，银行越多被抓的概率会越来越小，是不合理的
int main()            /// 所以应该用1-被抓概率=存活概率，存活概率相乘才能得到更小的存活概率，这才是合理的，最终比较时，老妈给的也是最大风险概率，不能超过这个概率，反过来，1-风险=存活
{                     /// 也就是不能存活概率不能低于某个值
    int t, n, i, j,
        v[ 1080 ];                        /// 100个银行，每个银行最多100价值，也就是最大价值为10000，因此数组要存到10000
    double dp[ 10800 ], w[ 1080 ], wmin;  /// 风险是小数，因此dp的应该是风险
    scanf( "%d", &t );
    while ( t-- ) {
        for ( i = 1; i <= 10020; i++ )  /// 100*100的数组，因此最大的是10000的dp数组
        {
            dp[ i ] = 0;  /// dp的是，在能抢到当前价值的情况下，存活的最大(max)概率值
        }
        scanf( "%lf%d", &wmin, &n );  /// 最大被抓概率 & 银行总数
        int sum = 0;
        for ( i = 1; i <= n; i++ ) {
            scanf( "%d%lf", &v[ i ], &w[ i ] );
            sum += v[ i ];        /// 求出最大价值以便作为dp的最大起点
            w[ i ] = 1 - w[ i ];  /// 将输入的 被抓概率 转变为 存活概率
        }

        dp[ 0 ] = 1;                /// 起点，因为是乘法，所以起始是1不是0
        for ( i = 1; i <= n; i++ )  /// 一家一家银行选
        {
            for ( j = sum; j >= v[ i ]; j-- ) {
                dp[ j ] = max( dp[ j ],
                               ( dp[ j - v[ i ] ] * w[ i ] ) );  /// 对银行的风险进行取舍，选取存活概率最大的放入dp数组中
            }
            //            for(int k=sum; k>=0; k--)
            //            {
            //                printf("%f\n",dp[k]);
            //            }
            //            printf("\n");
        }
        int ans = 0;
        for ( i = sum; i >= 0; i-- )  /// 在dp后，从价值最大的往回找，直到找到某个价值的存活概率大于不能低于的的存活概率(因为获得的价值越多要抢的银行越多，存活的概率也是越少的，所以越上面的概率就越小)
        {
            if ( 1 - wmin <= dp[ i ] )  /// 这里要将被抓概率转换为存活概率来比较
            {
                ans = i;  /// 记录此时能获得的价值
                break;
            }
        }
        printf( "%d\n", ans );
    }
    return 0;
}
