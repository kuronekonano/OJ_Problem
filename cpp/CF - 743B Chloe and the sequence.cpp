#include <math.h> ///然后每次做一个操作，将上一轮得到的序列放在最末端，在上一轮原本的序列后面加上一个n值
#include <stdio.h> ///一开始给一个序列，只有一个元素1
int main() {
  long long n, k;
  while (scanf("%lld%lld", &n, &k) != EOF) {
    if (k % 2 != 0)
      printf("1\n");
    else {
      long long flag = 0;
      long long half = pow(2, n - 1);
      k = k % half;
      while (k != half && k != 0) {
        k = k * 2;
        flag++;
        if (k > half)
          k = k % half;
      }
      printf("%lld\n", n - flag);
    }
  }
}
/// 第0次   1
/// 第1次   1 2 1
/// 第2次   1 2 1 3 1 2 1
/// 第4次   1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
/// 第5次   1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
/// 以此类推.....
/// 可以看出，无论n等于多少，序列都是固定的，第k位都是固定一个数的，因此n只决定序列有多长
/// 然后所有的奇数k值都是1
/// 然后，选择一个k值(偶数)时，将其一直*2，最后可以达到序列n长度的一半，此时序列n长度的一半，刚好是输入的n值
/// 因此，从k*2一直到n的一半的次数，就是flag，用n值减去这个次数，即可得到第k位的数，当k值不是2的n次方中的值时
///*2过程中会超出而不等于n序列长度的一半，当超过后，对k取摸，再继续*2，达到half的次数仍然可以用n值减
