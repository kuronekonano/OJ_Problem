#include <stdio.h> ///将问题简化为，判断是否是一整个大环，也就是判断是否存在多个环，存在几个环
#include <string.h> ///如果存在几个环，就要改动几次，将其变成一个大环
bool vis
    [200008]; /// 题目原意为，有n个烤架，分别为p1,p2,p3....pn，每个烤炉上有个标识b1,b2,b3...bn表示到达这个烤炉时要不要翻面
int p
    [200008]; /// 问，要将n个烤肉，使每个烤肉都在所有烤架上烤过，并且是两面都烤过，需要将现有的顺序最少改动几次
void dfs(
    int i) /// p1,p2,p3等数组上表示的数字，指的是在这个烤炉上的肉，下一秒将要到达几号烤炉，也就是链状表示。
{
  vis[i] = true;
  if (!vis[p[i]]) {
    dfs(p[i]);
  }
}
int main() /// 如果这样的链状表示，使一个烤肉可以通过此种传递循环一圈，则形成一个环，如果这个环到达过每个烤炉，这就是题目要求的情况，所有烤炉形成大环。
{
  int i, n, flag, ans, tmp;
  while (
      scanf("%d", &n) !=
      EOF) /// 还有就是，关于每个烤炉都要烤肉的双面，可以直接模拟一下，发现有奇数个1(到达此烤炉需要翻面)时，每圈到达每个烤炉的正反状态都会不同
  {
    flag = 0;
    memset(vis, false,
           sizeof(vis)); /// 这就实现了多转两圈后，所有肉在每个烤炉上烤过双面。
    for (i = 1; i <= n; i++)
      scanf("%d", &p[i]);
    for (i = 1; i <= n; i++) {
      scanf("%d", &tmp);
      if (tmp)
        flag++; /// 直接计数1的个数，如果为偶数，说明要改变某个为烤炉的01状态，操作数+1
    }
    ans = 0;
    if (flag % 2 == 0)
      ans++;
    flag = 0;
    for (
        i = 1; i <= n;
        i++) /// 判断环的数量时，用标记数组vis和深入传递的深搜，从第一个入手，一次搜到底，再遍历剩下的烤炉，如果还有未标记的说明不止一个环，因为上次遍历环还有烤炉没有到达过
    {
      if (!vis[i]) {
        flag++;
        dfs(i);
      }
    }
    if (flag == 1)
      flag = 0; /// 如果环的计数只有1，说明就是一个大环，不需要操作，操作数为0
    printf(
        "%d\n",
        ans +
            flag); /// 最后结果是环的数量(同时也是将其改变成一整个大环的操作数)加上01状态的操作数
  }
}
