#include <math.h>   ///因为每个数量的球最后达到这种做操作不变化的状态，都形成了一个从1到ans个盒子数，以此递增1个球的情况
#include <stdio.h>  ///由题意可知，经过一轮这样的变换之后，和变换之前状态不变才能算作一次最大盒子数量的统计
int main()          /// 也就是一个公差为1，首项为1的等差数列，利用n*(n+1)/2=球总数
                    /// 的求和公式，得到当球的个数达到一个值时，最多也就使用那么多球来变换出这个最长的递增序列
{
    long long t, n,
        cas = 0;  /// 又因为n*(n+1)约等于一个n*n的值，当球为3时，是1+2两个盒子，当球为4和5时，使用的球仍是3个，盒子仍是两个，这样说明，盒子数*（盒子数+1）<=
                  /// 球的数量
    scanf( "%lld",
           &t );  /// 用球数量的两倍开方可以约等于一个ans值，将这个值缩小，就可以达到一个ans*(ans+1)不大于而小于等于2*n的值，注意输出结果是使用球的数量
    while ( t-- ) {
        cas++;
        scanf( "%lld", &n );
        long long ans = sqrt( 2 * n );
        while ( ans * ( ans + 1 ) > 2 * n )
            ans--;
        printf( "Case #%lld: %lld\n", cas, ans * ( ans + 1 ) / 2 );
    }
}
