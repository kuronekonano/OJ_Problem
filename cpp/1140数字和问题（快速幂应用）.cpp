#include <stdio.h>
int main() {
  long long a, b, n; /// 此处求数字和，用到了数字和公式(x+8)%9+1
  while (scanf("%lld%lld", &a, &b) != EOF) {
    if (a == 0) {
      printf("0\n");
      continue;
    }
    long long k = 1; /// k值存储最终结果
    n = a;           /// n值存储一直变化的a的平方，
    while (b != 0)   /// 快速幂模板（循环结构）
    {
      if (b % 2 != 0) /// 简化为，当幂次为奇数时，把它分开先乘到最终结果中
      {
        /// 当b幂次除到0时说明已经把所有幂次乘完
        k = ((k % 9) * (n % 9)) %
            9; /// 剩下的可以平分的，一轮一轮平方的平方来缩短计算次数
      }
      n = ((n % 9) * (n % 9)) % 9; /// 往下乘到更大的数
      b = b / 2;                   /// 幂次每次要除2
    }
    if (k ==
        0) /// 特别注意当a=9时，k是直接被模成1的，因此注意k为0时的情况一定是9的倍数，最后结果一就为9了（A^B%9=0）,直接8+1，而不是0
    {
      printf("9\n");
      continue;
    }
    printf("%lld\n", k);
  }
  return 0;
}
///(a^b+8)%9+1
///=[(a^b+8)%9+1%9]%9
///=(a^b+9)%9
///=(a^b%9+9%9)%9
///=(a^b%9+0)%9
///=a^b%9
/// 因此这里直接是a的b次方模9的计算
/// int result=1;
/// while(b!=0)
///{
///    if(b%2!=0)
///    {
///        result=result*a;
///    }
///    a=a*a;
///    b=b/2;
///}
/// return result;
