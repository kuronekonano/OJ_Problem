#include <stdio.h> ///题意，从某个人开始打电话，打给下一个人，数组的位置表示是第几个人，数组中存的数表示打给谁，类似链表一样的存储方式
#include <string.h> ///然后对于所有人，1~n，都有一个t值，表示，当打电话存在存在一个环时(最后能有人打给自己)，t的最小值是多少。
long long
gcd(long long a,
    long long
        b) /// 如果打电话不存在环，或者有某人不在环中，成了一条直线，那就输出-1
{
  while (
      b !=
      0) /// t的意思是
         /// 从x->y经过了t人，再从y->x，也经过了t人，则是t值，因为这个t是对所有环通用的，所以他应该是所有环的长度的公倍数，又要求t的最小值，所以是最小公倍数
  {
    long long c = b;
    b = a % b;
    a = c;
  }
  return a; /// 因为t通用，所以t对于某个较大的环来说，可能是打出了一半的人，或者刚好打出了换的长度的人数，对于较小的环，则会循环打出几轮。
}
int main() {
  long long n, a[108],
      i; /// 步骤就是，先找出一个环，因为必定会存在环，否则不存在环就不用求t值，直接输出-1，所以先找出一个环，然后得到这个环的长度。
  bool vis[108];
  while (scanf("%lld", &n) != EOF) {
    memset(
        vis, false,
        sizeof(
            vis)); /// 用标记数组标记某个节点是否走过，如果走过就不用再从这个点遍历他在哪个环里了
    for (i = 1; i <= n; i++) {
      scanf("%d", &a[i]);
    }
    bool flag = false; /// 是否存在非环的标记
    long long sum =
        1; /// 最后最小的t值的存储，因为要连续用于求最小公倍数，因此用long
           /// long 而且初值为1是不会影响结果
    for (i = 1; i <= n; i++) /// 从第一个人开始检查环
    {
      if (vis[i]) /// 如果遍历的那个人已经被标记，说明他属于别的环了，不用再从这个点开始检查环
        continue;
      int x = a[i];
      vis[a[i]] =
          true; /// 开始的这个点打给的下一个人被标记，也就是说，要保证每一个人都接到了电话才算是一个环
      long long cnt = 1; /// 环的长度计数，第一个人算是环的1个长度
      while (
          x !=
          i) /// 开始按着每个人存的下一个人的位置往下找人，直到找到的x回到的初始的i位置
      {
        x = a[x];      /// 传递
        vis[x] = true; /// 标记
        cnt++;         /// 长度计数
        if (cnt >
            n) /// 当长度大于总人数时，说明无限往下打电话，形成直线，不存在环，结束判断，直接-1
        {
          flag = true;
          break;
        }
      }
      if (flag)
        break;
      if (cnt % 2 == 0)
        cnt /=
            2; /// 注意，这个t值是从x->y的长度，也是y->x的长度，如果是奇数长度环，那么x=y，t必为环长度，如果是偶数环，那么从这个环中间的那个人结束，再从他开始，就是t的值，所以要/2表示t
      sum =
          sum * cnt /
          gcd(cnt,
              sum); /// 最后得到一个环的长度就去求他们的最小公倍数，来一个求一个，求的是所有的环长度的最小公倍数
    }
    if (flag) {
      printf("-1\n");
      continue;
    } else {
      printf("%lld\n", sum);
    }
  }
}
