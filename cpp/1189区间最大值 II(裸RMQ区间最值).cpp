#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <string.h>
using namespace std;
int dmax[ 100005 ][ 25 ];  /// 一个dp数组只能dp最大值或最小值，因此同时需要两个最值时就需要两个数组分别dp
int a[ 100005 ];
int rmq_max( int l,
             int r )  /// 最大值查找函数,输入范围的起点L和终点R，这里表示的是数组的位置而不是数的值
{
    int k = log2( r - l + 1 );
    //    while(1<<(k+1)<=r-l+1)///r-l+1算的是范围，从第l个数到第r个数共存在l-r+1个数字
    //    {
    //        k++;///一直增长的k表示范围在以2的指数的方式增长,同时，k查找的是第几列存储的最值，第一列就是范围2，第二列就是范围4
    //    }
    return max( dmax[ l ][ k ],
                dmax[ r - ( 1 << k ) + 1 ][ k ] );  /// 起始点的前半段最值就是第l行k列，终止点后半段的最值，同样是k列，但是行数是r-范围，结果
}  /// 当r-范围=0时，+1后得到起始点记录的k次方范围的最值，当r-范围=初始点位置时，+1后表示后半段的最值，因此，return比较的函数不是二选一就是自己和自己比
int main() {
    int n, i, j, q, flag = 0;
    while ( scanf( "%d", &n ) != EOF ) {
        memset( dmax, 0, sizeof( dmax ) );
        for ( i = 1; i <= n; i++ )  /// 直接输入到dp数组中，不需要初始化了
        {
            scanf( "%d", &dmax[ i ][ 0 ] );
        }
        for ( int j = 1; ( 1 << j ) < n; j++ )  /// 状态转移，进行数组dp操作,从列开始，先两个两个比较，如d第一个数和第二个数，找出最大和最小，然后第二和第三个数比较
        {
            for ( int i = 0; i + ( 1 << j ) - 1 <= n;
                  i++ )  /// 第0列存储的是原数组，也是初始化的dp入口,第1列开始记录两两中的最值，第2列记录四个四个的最值，获取方法是从上一列中的最值中挑选，这样就能得到两段中的最值并继承下去
            {
                dmax[ i ][ j ] = max( dmax[ i ][ j - 1 ],
                                      dmax[ i + ( 1 << ( j - 1 ) ) ][ j - 1 ] );  /// 以求得下一整段中的最值
            }  /// 范围的增长因为是两端两段的，因此是2的j-1次方，同时，当前遍历的第j列也是存储最大值的，第i行，则表示从此位置开始，直到某个终点的范围内中的最值
        }  /// 遍历时所筛选的j-1列是找上一轮中两个范围的最值，并从中筛选，i是逐一递增的，也就是说起点的指针是一个个移动的，终点也因此一个个移动。
        int l,
            r;  /// 但范围，是由j外层循环决定的，外层的2的j-1次方，表示增长的范围，当范围加上i时就表示终点的位置
        //        for(i=0;i<=n;i++)
        //        {
        //            for(int j=0;j<=n;j++)
        //            {
        //                printf("%d%c",dmax[i][j],j==n?'\n':' ');
        //            }
        //        }
        scanf( "%d", &q );
        int t = q - 1;
        while ( q-- ) {
            scanf( "%d%d", &l, &r );
            a[ q ] = rmq_max( l, r );
        }
        flag++;
        printf( "Case %d:\n", flag );
        for ( i = t; i >= 0; i-- ) {
            printf( "%d\n", a[ i ] );
        }
    }
    return 0;
}
