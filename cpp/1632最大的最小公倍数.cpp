#include <stdio.h> ///注意用long long
int main() {
  long long n;
  while (scanf("%lld", &n) != EOF) {
    if (n <= 2) /// 小于2的最小公倍数只能是它本身
    {
      printf("%lld\n", n);
    } else /// 奇偶两种情况
    {
      if (n % 2 != 0) /// 奇数，三个数互质且成绩最大条件，奇 偶 奇
      {
        n = n * (n - 1) * (n - 2);
      } else /// 偶数，两种情况
      {
        if ((n - 3) % 3 == 0) /// 预防n-3与n同时是三的倍数时
        {
          n = (n - 1) * (n - 2) *
              (n - 3); /// 为保持 偶 奇 偶
                       /// 模式不变，奇数仍为n-1，偶数最大值从原来的n变成n-2
        } else {
          n = n * (n - 1) * (n - 3); /// 否则直接取最大的 偶 奇 偶 形式
        }
      }
      printf("%lld\n", n);
    }
  }
  return 0;
}
/// 在一组数中找三个数，使他们的最小公倍数最大，我们知道，两个数的最小公倍数在最大的情况就是当两个数互质的时候，
/// 他们的最小公倍数就是这两个数的乘积，而且还有那么一个定理，即两个相邻的自然数互质，即使我们不知道定理怎么证
/// 明，但大体能想出来，但这是三个数，也就是说存在  奇-偶-奇  和 偶-奇-偶
/// 两种情况。

///     一：奇-偶-奇 这种情况用于n是奇数的情况，即 最大的三个数就是
///     n，n-1，n-2，那么可以看到，因为n和n-2都是奇数，
/// 所以肯定不存在公因数2，假设三个数中有一个存在因数3，那么另外两个肯定不存在因数3，因为他们的变化范围都小于3，
/// 也就是说，这三个数不仅是最大的，还是互质的，也就是说最大的最小公倍数就是这三个数的乘积，即n*（n-1）*（n-2）
/// 相信大部分人都可以想到这一步

///     二：偶-奇-偶
///     对于这种情况两个偶数肯定是存在公因数2，也就是意味着最小公倍数要除以2，这是绝对不能容忍的，所以
/// 我们稍微缩小一下数，即n，n-1，n-3，这样就又变成奇-偶-奇的结构了，但还有一个问题，就是假如偶数n存在因数3，那
/// 么n-3也必定有因数3，这直接导致最小公倍数除以3，更加不能容忍，为了保持奇-偶-奇的结构不变，只能变那个偶数，而
/// 离他最近的偶数就是n-2了，这下就完美了，3个数依然是互质的，最小公倍数就是（n-1）*（n-2）*（n-3）
