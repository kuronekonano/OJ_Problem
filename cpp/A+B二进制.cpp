#include <algorithm>
#include <math.h>
#include <stdio.h> //就是一个大数加法
#include <string.h>
using namespace std;

char numa[10005], numb[10005]; // 定义两个字符型数组用于存储两个输入的二进制数
int main() {
  int na, nb, a[1005], b[1005],
      c[1005]; // 定义两个整型数组用于存储讲字符型转化为整型后的数，c数组用于存储相加后结果
  int i;
  while (scanf("%s%s", numa, numb) != EOF) // 输入两个要相加的数
  {
    int jw = 0;              // 初始化 进位计数器
    memset(a, 0, sizeof(a)); // 清空用于存储整型数字的数组
    memset(b, 0, sizeof(b));
    na = strlen(numa); // 计算两个字符串长度
    nb = strlen(numb);
    for (
        i = 0; i < na;
        i++) // 循环遍历输入的字符串，并减掉字符‘0’，转换为整型数字存储于数组中
    {
      a[i] = numa[na - i - 1] - '0'; // 数a
    }
    for (i = 0; i < nb; i++) {
      b[i] = numb[nb - i - 1] - '0'; // 数b
    }
    int big =
        max(na, nb); // 找到两数中最长长度的数，并以之作为最后求和位数的标准
    memset(c, 0, sizeof(c)); // 使用前清空用于存储结果的数组c
    for (i = 0; i < big;
         i++) // 开始相加，从数组第0位开始，循环次数小于最大字符串长度
    {
      c[i] = a[i] + b[i] +
             jw; // 每次循环求a与b的第i位的和，并加上上一位的进位,初始进位为0
      if (c[i] >= 2) // 循环中，若求和后那位数大于2,则进位
      {
        jw =
            c[i] /
            2; // 进位等于那位数除2，不能直接等于1，防止前几位相加进位传递过来求和等于3，原理等同于十进制中进位，进位数等于当位求和后除10
        c[i] = c[i] % 2; // 取当位求和数取摸作为个位数
      } else {
        jw = 0; // 若小于2，则初始化进位计数器，防止因上上位进位而残留的进位数据
      }
    }
    if (jw !=
        0) // 至最大位数相加结束后，若进位计数器仍不为0，则增大最大位数长度
    {
      while (jw) // 当jw变量不为0时，循环继续
      {
        c[big] = jw % 2; // 最大位数等于进位计数器内存储的数字求模2的值
        jw = jw / 2;     // 进位计数器除2后可为0
        big++; // 若超过2，则继续往下加位数，并计算，若已经加够，则增添了数组中一位存储
      }
    }
    int flag = 0; // 开始输出
    for (
        i = big; i >= 0;
        i--) // 循环遍历存储结果的数组i，因为相加计算时时从最低位开始计算，并存储于c[i]数组对应位数中
    {
      if (flag == 0 &&
          c[i] !=
              0) // 输出是应倒序输出，保证最高位在前面先输出,最高位不为0时开始输出
      {
        flag = 1;           // 表示开始输出
        printf("%d", c[i]); // 执行输出i位
        continue;           // 输出后重新循环
      }
      if (flag == 1) // 判断已经开始输出后就不需要确定是否最高位位0
      {
        printf("%d", c[i]); // 直接连续输出后面位数
      }
    }
    if (flag ==
        0) // 若前面循环一直遍历每一位都为0时，说明求和结果就是0，开始输出标准并未开启
    {
      printf("0"); // 此时直接输出0
    }
    printf("\n"); // 处理完输出后就可以换行了
  }
  return 0;
}
