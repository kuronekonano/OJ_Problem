#include<stdio.h>///一开始给一个序列，只有一个元素1
#include<math.h>///然后每次做一个操作，将上一轮得到的序列放在最末端，在上一轮原本的序列后面加上一个n值
int main()
{
    long long n,k;
    while(scanf("%lld%lld",&n,&k)!=EOF)
    {
        if(k%2!=0)printf("1\n");
        else
        {
            long long flag=0;
            long long half=pow(2,n-1);
            k=k%half;
            while(k!=half&&k!=0)
            {
                k=k*2;
                flag++;
                if(k>half)k=k%half;
            }
            printf("%lld\n",n-flag);
        }
    }
}
///第0次   1
///第1次   1 2 1
///第2次   1 2 1 3 1 2 1
///第4次   1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
///第5次   1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1
///以此类推.....
///可以看出，无论n等于多少，序列都是固定的，第k位都是固定一个数的，因此n只决定序列有多长
///然后所有的奇数k值都是1
///然后，选择一个k值(偶数)时，将其一直*2，最后可以达到序列n长度的一半，此时序列n长度的一半，刚好是输入的n值
///因此，从k*2一直到n的一半的次数，就是flag，用n值减去这个次数，即可得到第k位的数，当k值不是2的n次方中的值时
///*2过程中会超出而不等于n序列长度的一半，当超过后，对k取摸，再继续*2，达到half的次数仍然可以用n值减
