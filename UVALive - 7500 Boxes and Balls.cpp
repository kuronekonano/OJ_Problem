#include<stdio.h>///由题意可知，经过一轮这样的变换之后，和变换之前状态不变才能算作一次最大盒子数量的统计
#include<math.h>///因为每个数量的球最后达到这种做操作不变化的状态，都形成了一个从1到ans个盒子数，以此递增1个球的情况
int main()///也就是一个公差为1，首项为1的等差数列，利用n*(n+1)/2=球总数  的求和公式，得到当球的个数达到一个值时，最多也就使用那么多球来变换出这个最长的递增序列
{
    long long t,n,cas=0;///又因为n*(n+1)约等于一个n*n的值，当球为3时，是1+2两个盒子，当球为4和5时，使用的球仍是3个，盒子仍是两个，这样说明，盒子数*（盒子数+1）<= 球的数量
    scanf("%lld",&t);///用球数量的两倍开方可以约等于一个ans值，将这个值缩小，就可以达到一个ans*(ans+1)不大于而小于等于2*n的值，注意输出结果是使用球的数量
    while(t--)
    {
        cas++;
        scanf("%lld",&n);
        long long ans=sqrt(2*n);
        while(ans*(ans+1)>2*n)ans--;
        printf("Case #%lld: %lld\n",cas,ans*(ans+1)/2);
    }
}
