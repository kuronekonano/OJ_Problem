#include <algorithm>
#include <math.h>
#include <stdio.h>
#include <string.h>
using namespace std;
int dmax
    [100005]
    [25]; /// 一个dp数组只能dp最大值或最小值，因此同时需要两个最值时就需要两个数组分别dp
int a[100005];
int rmq_max(
    int l,
    int r) /// 最大值查找函数,输入范围的起点L和终点R，这里表示的是数组的位置而不是数的值
{
  int k = log2(r - l + 1);
  //    while(1<<(k+1)<=r-l+1)///r-l+1算的是范围，从第l个数到第r个数共存在l-r+1个数字
  //    {
  //        k++;///一直增长的k表示范围在以2的指数的方式增长,同时，k查找的是第几列存储的最值，第一列就是范围2，第二列就是范围4
  //    }
  return max(
      dmax[l][k],
      dmax[r - (1 << k) + 1]
          [k]); /// 起始点的前半段最值就是第l行k列，终止点后半段的最值，同样是k列，但是行数是r-范围，结果
} /// 当r-范围=0时，+1后得到起始点记录的k次方范围的最值，当r-范围=初始点位置时，+1后表示后半段的最值，因此，return比较的函数不是二选一就是自己和自己比
int main() {
  int n, i, j, q, flag = 0;
  while (scanf("%d", &n) != EOF) {
    memset(dmax, 0, sizeof(dmax));
    for (i = 1; i <= n; i++) /// 直接输入到dp数组中，不需要初始化了
    {
      scanf("%d", &dmax[i][0]);
    }
    for (
        int j = 1; (1 << j) < n;
        j++) /// 状态转移，进行数组dp操作,从列开始，先两个两个比较，如d第一个数和第二个数，找出最大和最小，然后第二和第三个数比较
    {
      for (
          int i = 0; i + (1 << j) - 1 <= n;
          i++) /// 第0列存储的是原数组，也是初始化的dp入口,第1列开始记录两两中的最值，第2列记录四个四个的最值，获取方法是从上一列中的最值中挑选，这样就能得到两段中的最值并继承下去
      {
        dmax[i][j] =
            max(dmax[i][j - 1],
                dmax[i + (1 << (j - 1))][j - 1]); /// 以求得下一整段中的最值
      } /// 范围的增长因为是两端两段的，因此是2的j-1次方，同时，当前遍历的第j列也是存储最大值的，第i行，则表示从此位置开始，直到某个终点的范围内中的最值
    } /// 遍历时所筛选的j-1列是找上一轮中两个范围的最值，并从中筛选，i是逐一递增的，也就是说起点的指针是一个个移动的，终点也因此一个个移动。
    int l,
        r; /// 但范围，是由j外层循环决定的，外层的2的j-1次方，表示增长的范围，当范围加上i时就表示终点的位置
    //        for(i=0;i<=n;i++)
    //        {
    //            for(int j=0;j<=n;j++)
    //            {
    //                printf("%d%c",dmax[i][j],j==n?'\n':' ');
    //            }
    //        }
    scanf("%d", &q);
    int t = q - 1;
    while (q--) {
      scanf("%d%d", &l, &r);
      a[q] = rmq_max(l, r);
    }
    flag++;
    printf("Case %d:\n", flag);
    for (i = t; i >= 0; i--) {
      printf("%d\n", a[i]);
    }
  }
  return 0;
}
