#include<stdio.h>//就是一个大数加法
#include<string.h>
#include<math.h>
#include<algorithm>
using namespace std;

char numa[10005],numb[10005];//定义两个字符型数组用于存储两个输入的二进制数
int main()
{
    int na,nb,a[1005],b[1005],c[1005];//定义两个整型数组用于存储讲字符型转化为整型后的数，c数组用于存储相加后结果
    int i;
    while(scanf("%s%s",numa,numb)!=EOF)//输入两个要相加的数
    {
        int jw=0;//初始化 进位计数器
        memset(a,0,sizeof(a));//清空用于存储整型数字的数组
        memset(b,0,sizeof(b));
        na=strlen(numa);//计算两个字符串长度
        nb=strlen(numb);
        for(i=0;i<na;i++)//循环遍历输入的字符串，并减掉字符‘0’，转换为整型数字存储于数组中
        {
            a[i]=numa[na-i-1]-'0';//数a
        }
        for(i=0;i<nb;i++)
        {
            b[i]=numb[nb-i-1]-'0';//数b
        }
        int big=max(na,nb);//找到两数中最长长度的数，并以之作为最后求和位数的标准
        memset(c,0,sizeof(c));//使用前清空用于存储结果的数组c
        for(i=0;i<big;i++)//开始相加，从数组第0位开始，循环次数小于最大字符串长度
        {
            c[i]=a[i]+b[i]+jw;//每次循环求a与b的第i位的和，并加上上一位的进位,初始进位为0
            if(c[i]>=2)//循环中，若求和后那位数大于2,则进位
            {
                jw=c[i]/2;//进位等于那位数除2，不能直接等于1，防止前几位相加进位传递过来求和等于3，原理等同于十进制中进位，进位数等于当位求和后除10
                c[i]=c[i]%2;//取当位求和数取摸作为个位数
            }
            else
            {
                jw=0;//若小于2，则初始化进位计数器，防止因上上位进位而残留的进位数据
            }
        }
        if(jw!=0)//至最大位数相加结束后，若进位计数器仍不为0，则增大最大位数长度
        {
            while(jw)//当jw变量不为0时，循环继续
            {
                c[big]=jw%2;//最大位数等于进位计数器内存储的数字求模2的值
                jw=jw/2;//进位计数器除2后可为0
                big++;//若超过2，则继续往下加位数，并计算，若已经加够，则增添了数组中一位存储
            }
        }
        int flag=0;//开始输出
        for(i=big;i>=0;i--)//循环遍历存储结果的数组i，因为相加计算时时从最低位开始计算，并存储于c[i]数组对应位数中
        {
            if(flag==0&&c[i]!=0)//输出是应倒序输出，保证最高位在前面先输出,最高位不为0时开始输出
            {
                flag=1;//表示开始输出
                printf("%d",c[i]);//执行输出i位
                continue;//输出后重新循环
            }
            if(flag==1)//判断已经开始输出后就不需要确定是否最高位位0
            {
                printf("%d",c[i]);//直接连续输出后面位数
            }
        }
        if(flag==0)//若前面循环一直遍历每一位都为0时，说明求和结果就是0，开始输出标准并未开启
        {
            printf("0");//此时直接输出0
        }
        printf("\n");//处理完输出后就可以换行了
    }
    return 0;
}
