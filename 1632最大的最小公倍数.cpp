#include<stdio.h>///注意用long long
int main()
{
    long long n;
    while(scanf("%lld",&n)!=EOF)
    {
        if(n<=2)///小于2的最小公倍数只能是它本身
        {
            printf("%lld\n",n);
        }
        else///奇偶两种情况
        {
            if(n%2!=0)///奇数，三个数互质且成绩最大条件，奇 偶 奇
            {
                n=n*(n-1)*(n-2);
            }
            else///偶数，两种情况
            {
                if((n-3)%3==0)///预防n-3与n同时是三的倍数时
                {
                    n=(n-1)*(n-2)*(n-3);///为保持 偶 奇 偶 模式不变，奇数仍为n-1，偶数最大值从原来的n变成n-2
                }
                else
                {
                    n=n*(n-1)*(n-3);///否则直接取最大的 偶 奇 偶 形式
                }
            }
            printf("%lld\n",n);
        }
    }
    return 0;
}
///在一组数中找三个数，使他们的最小公倍数最大，我们知道，两个数的最小公倍数在最大的情况就是当两个数互质的时候，
///他们的最小公倍数就是这两个数的乘积，而且还有那么一个定理，即两个相邻的自然数互质，即使我们不知道定理怎么证
///明，但大体能想出来，但这是三个数，也就是说存在  奇-偶-奇  和 偶-奇-偶 两种情况。

///     一：奇-偶-奇 这种情况用于n是奇数的情况，即 最大的三个数就是 n，n-1，n-2，那么可以看到，因为n和n-2都是奇数，
///所以肯定不存在公因数2，假设三个数中有一个存在因数3，那么另外两个肯定不存在因数3，因为他们的变化范围都小于3，
///也就是说，这三个数不仅是最大的，还是互质的，也就是说最大的最小公倍数就是这三个数的乘积，即n*（n-1）*（n-2）
///相信大部分人都可以想到这一步

///     二：偶-奇-偶 对于这种情况两个偶数肯定是存在公因数2，也就是意味着最小公倍数要除以2，这是绝对不能容忍的，所以
///我们稍微缩小一下数，即n，n-1，n-3，这样就又变成奇-偶-奇的结构了，但还有一个问题，就是假如偶数n存在因数3，那
///么n-3也必定有因数3，这直接导致最小公倍数除以3，更加不能容忍，为了保持奇-偶-奇的结构不变，只能变那个偶数，而
///离他最近的偶数就是n-2了，这下就完美了，3个数依然是互质的，最小公倍数就是（n-1）*（n-2）*（n-3）
