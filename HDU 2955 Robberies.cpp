#include <algorithm>
#include <stdio.h> ///活用dp
#include <string.h>
using namespace std; /// 需要注意的是，数据给的是被抓的概率，因此是要相乘(不是相加！！)才能得到同时抢几家银行被抓的概率，但这样，银行越多被抓的概率会越来越小，是不合理的
int main() /// 所以应该用1-被抓概率=存活概率，存活概率相乘才能得到更小的存活概率，这才是合理的，最终比较时，老妈给的也是最大风险概率，不能超过这个概率，反过来，1-风险=存活
{          /// 也就是不能存活概率不能低于某个值
  int t, n, i, j,
      v[1080]; /// 100个银行，每个银行最多100价值，也就是最大价值为10000，因此数组要存到10000
  double dp[10800], w[1080], wmin; /// 风险是小数，因此dp的应该是风险
  scanf("%d", &t);
  while (t--) {
    for (i = 1; i <= 10020; i++) /// 100*100的数组，因此最大的是10000的dp数组
    {
      dp[i] = 0; /// dp的是，在能抢到当前价值的情况下，存活的最大(max)概率值
    }
    scanf("%lf%d", &wmin, &n); /// 最大被抓概率 & 银行总数
    int sum = 0;
    for (i = 1; i <= n; i++) {
      scanf("%d%lf", &v[i], &w[i]);
      sum += v[i];     /// 求出最大价值以便作为dp的最大起点
      w[i] = 1 - w[i]; /// 将输入的 被抓概率 转变为 存活概率
    }

    dp[0] = 1;               /// 起点，因为是乘法，所以起始是1不是0
    for (i = 1; i <= n; i++) /// 一家一家银行选
    {
      for (j = sum; j >= v[i]; j--) {
        dp[j] = max(
            dp[j],
            (dp[j - v[i]] *
             w[i])); /// 对银行的风险进行取舍，选取存活概率最大的放入dp数组中
      }
      //            for(int k=sum; k>=0; k--)
      //            {
      //                printf("%f\n",dp[k]);
      //            }
      //            printf("\n");
    }
    int ans = 0;
    for (
        i = sum; i >= 0;
        i--) /// 在dp后，从价值最大的往回找，直到找到某个价值的存活概率大于不能低于的的存活概率(因为获得的价值越多要抢的银行越多，存活的概率也是越少的，所以越上面的概率就越小)
    {
      if (1 - wmin <= dp[i]) /// 这里要将被抓概率转换为存活概率来比较
      {
        ans = i; /// 记录此时能获得的价值
        break;
      }
    }
    printf("%d\n", ans);
  }
  return 0;
}
